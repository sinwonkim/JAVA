제어자modifier
제어자란 클래스와 클래스 멤버의 선언시 사용하여 부가적인 의미를 부여하는 키워드르 ㄹ의미
자바에서 제어자는 접근 제어자와 기타 제어자로 구분할 수 있음

접근 제어자 access modifier
객체 지향에서 정보 은닉이란 사용자가 굳이 알 필요 없는 정보는 사용자로부터 숨겨야 한다는 개념 

자바에서는 이러한 정보 은닉을위해 접근 제어자 라는 기능을 제공하고 있다. 
접근 제어자를 사용하면 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 구체화할 수 있다.

자바에서는 다음가 같은 네 가지의 접근 제어자를 제공

1.private
private 접근 제어자를 사용하면 선언된 클래스 멤버는 외부에 공개되지 않으며, 외부에서는 직접 접근 x
즉,자바프로그램 private 멤버에 직접 접근할 수 없으며, 해당 객체의 public 메소드를 통해서만 접근 할 수 있다.
따라서 private 멤버는 public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는데 사용됨

ex) private 멤버는 해당 멤버를 선언한 클래스에서만 접근 할 수 있다.
같은 클래스에만 접근 허용
public class SameClass{
  private String var = "같은 클래스만 허용"; // private필드
  
  private String getVar() { // private 메소드
    return this.var;
  }

}






2.public 접근제어자
public 접근 제어자를 사용하여 선언된 클래스 메멉는 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 접근 o
자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다.
따라서 public 메소드는 private 멤버와 프로그램 사이의 인터페이스 역할을 수행한다고 볼 수 있다.

ex)
public class EveryWhere() {

  public String var = '누구든지 허용'; // public 필드
  
  public String getVar() { // public 메소드
  
    return this.var;
  }

}
3.default

4.protected
부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됨


기타 제어자
final 제어자
자바에서 final제어자는 '변경할 수 없다'는 의미로 사용됨 

즉,필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수constant가 된다.
또한, 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없게 된다.
매소드에 사용하면 해당 메소드는 오버라이딩을 통한 재정의 할수 x

자바에서는 상속이라는 것을 통해 다른 클래스의 private 멤버를 제외한 모든 메소드를 상속 받을 수 있다.
이렇게 상속받은 메소드는 그대로 사용해도 되고,필요한 동작을 위해 재정의하여 사용할 수도 있다.
메소드 오버라이딩이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미한다.


static 제어자
자바에서 static 제어자는 '공통적인'이라는 의미로 사용된다.

즉,static 제어자를 변수에 사용하면 해당 변수를 클래스 변수로 만들어 준다.
또한,메소드에 사용하면 해당 메소드를 클래스 메소드로 만들어 준다.
이러한 static제어자는 초기화 블록에도 사용할 수 있다.

static 제어자를 가지는 멤버는 다음과 같은 특징을 가지게 된다.

1.프로그램 시작시 최초에 단 한번만 생성되고 초기화됨
2.인스턴스를 생성하지 않고도 바로 사용할 수 있다.
3.해당 클래스의 모든 인스턴스가 공유함 

자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같다.
-메소드,필드,초기화 블록
ex)
class Car{
  static int var; // 클래스 필드(static 변수)
  satic { // static 초기화 블록
  }
}

abstract 제어자
자바에서 abstract제어자는 '추상적인' 이라는 의미로 사용된다.

선언부만 있고 구현부가 없는 메소드를 추상 메소드라 하며, 반드시 abstract 제어자를 붙여야 한다.
ex)
abstract class Car{ // 추상 클래스

  abstract void brake(); // 추상 메소드
}




















이 내용은 tcp스쿨을 보고 개인적으로 정리할 목적으로 작성한 것입니다.

