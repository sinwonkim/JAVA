package Ex06;

public class WhatIsClass {
	public static void main(String[] args) {
		/*
		 * 소프트 웨어를 개발할 때에도 부품에 해당하는 객체들을 먼저 만들고, 
		 * 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍
		 * (OOP: ObjectOriented Programming)
		 * 
		 *  객체란? 
		 *  객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 
		 *  자신의 속성을 가지고 있고 
		 *  
		 *  객체는 속성과 동작으로 구성되어 있다. 
		 *  
		 *  현실 세계 
		 *  사람
		 *  [속성] 이름 , 나이
		 *  [동작] 웃다, 먹다.
		 *  
		 *  자동차
		 *  [속성] 색깔, 속도
		 *  [동작] 달린다, 멈춘다
		 *  
		 *  현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어져 있다.
		 *  예를 들어 전자계산기의 기능을 이용하고, 전자계산기는 계산 결과를 사람에게 알려주는
		 *  상호 작용을 한다. 
		 *  소프트웨어에서도 마찬가지이다. 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용
		 *  하면서 동작한다.
		 *  객체들 사이의 상호작용 수단은 메소드이다. 객체가 다른 객체의 기능을 이용하는 것이 바로 메소드 호출이다.
		 *  도트 연산자는 객체의 필드와 메소드에 접근할 때 사용한다.
		 *  전자계산기객체.메소드(매개값1, 매개값2)
		 *  
		 *  매개값은 메소드를 실행하기 위해 필요한 데이터이다. 예를 들어 10과 20을 주고 더하기 기능을 이용한다고 
		 *  했을 떄 10과 20이 더하기 기능의 매개값이다. 리턴값은 메소드가 실행하고 나서 호출한 곳으로 돌려주는(리턴하는)값이다.
		 *  객체의 상호작용은 객체간의 메소드 호출을 의미하며 매개값과 리턴값을 통해서 데이터를 서로 주고 받는다.
		 *  (***************************** 매우 중요 합니다!! 객체의 상호 작용은 객체간의 메소드 호출을 의미하며
		 *  매개값과 리턴값을 통해서 데이터를 서로 주고 받는다.) 
		 *  
		 *  객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다. 이 관계의 종류에는
		 *  집합 관게, 사용 관계, 상속 관계가 있다. 
		 *  집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다. 
		 *  ex) 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 
		 *  
		 *  사용 관계는 객체 간의 상호 작용을 말한다. 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.
		 *  예를 들어 사람은 자동차를 사용하므로 사람과 자동차는 사용의 관계라고 볼 수 있다.
		 *  사람이란 객체는 자동차를 사용할 때 달린다, 멈춘다 등의 메소드를 호출한다.
		 *  
		 *  상속 관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다.
		 *  
		 *  일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다. 
		 *  ex) 자동차는 기계의 종류이다. 기계(상위)와 자동차(하위)는 상속관계에 있다고 볼 수 있다. 
		 *  
		 *  객체 지향 프로그래밍(OOP : Object oriented Programming)은 만들고자 하는 완성품인 객체를 모델링 하고 
		 *  집합 관계에 있는 부품 객체와 사용관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을
		 *  개발하는 기법이다.
		 *  
		 *  객체 지향 프로그래밍의 특징 
		 *  객체 지향 프로그래밍의 특징으로는 캡슐화, 상속 , 다형성을 들 수 있다. 
		 *  
		 *  캡슐화(Encapsulation)
		 *  캡슐화란 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다.
		 *  외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
		 *  
		 *  필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록
		 *  하는데 있다. 
		 *  자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 
		 *  사용한다. 
		 *  접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.
		 *  
		 *  상속(Inheritance)
		 *  일반적으로 상속은 부모가 가지고 있는 재산을 자식에게 물려주는 것을 말한다. 자식은 특별한 노력없이 부모가
		 *  물려준 재산을 갖게 된다. 객체 지향 프로그래밍에서도 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다.
		 *  상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 해준다
		 *  
		 *  상위 객체 = 필드1 + 메소드1
		 *  하위 객체 = 필드1 + 메소드1 + 필드2 + 메소드2(추가 데이터 및 기능)
		 *	
		 *	상속은 상위 객체를 재사용ㅇ해서 하위객체를 쉽고 빨리 설계할 수 있도록 도와주고 , 이미 잘 개발된
		 *  객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여준다. 
		 *  상속은 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화 시켜주기도 한다.
		 *  
		 *  상속의 핵심 : 상속은 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 
		 *  			  최소화시켜주기도 한다.
		 *  
		 *  다형성(Polymorphism) 
		 *  다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면
		 *  다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
		 *  자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 
		 *  부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현객체가 대입될 수 있다.
		 *  다형성의 효과로 객체가 부품화가 가능하다. 예를 들어 자동차를 설계할 때 타이어 인터페이스 타입을 적용했다면
		 *  이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)이 가능하다.
		 * 
		 *  메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 자바에서는
		 *  설계도가 바로 클래스이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
		 *  클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다. 
		 *  자동차 객체는 자동차 클래스의 인스턴스인 셈이다. 
		 *  그리고 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다. 하나의 클래스로부터 여러개의 인스턴스를
		 *  만들 수 있는데, 이것은 동일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.
		 *  
		 *  객체 지향 프로그래밍 개발은 세 가지 단계가 있다. 첫 번째 단계는 클래스를 설계해야 한다.
		 *  두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 
		 *  그리고 마지막 단계는 생성된 객체를 이용하는 것이다. 
		 *  
		 *  클래스를 선언한 다음, 컴파일을 했다면(이클립스에서는 저장) 객체를 생성할 설계도가 만들어진 것이다.
		 *  클래스로부터 객체를 생성한 방법은 다음과 같이 new 연산자를 사용하면 된다.
		 *  new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스()
		 *  형태를 가지고 있다. new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 
		 *  현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이, 객체 지향 프로그램에서도 메모리 내에서 
		 *  생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 
		 *  그래서 new 연산자는 힙 영역에 객체를 생성 시킨 후, 객체의 주소를 리턴하도록 되어 있다.
		 *  이 주소를 참조 타입인 클래스 변수에 저장해 두면, 객체의 주소를 리턴하도록 되어 있다. 
		 *  이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.
		 *  
		 *  클래스 변수;
		 *  변수 = new 클래스();  // new 연산자로 객체를 생성하고 , 리턴된 객체의 주소를 변수에 저장하면 
		 *  						 다음과 같이 변수가 객체를 참조하게 된다.
		 *  
		 *  
		 * 
		 * 
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 * */
				Student student1 = new Student(); //student1변수로  student 객체를 참조한다.
				Student student2 = new Student(); //student2변수로  student 객체를 참조한다.
				// 예제가 실행되면 다음 그림과 같이 메모리에 클래스 변수와 객체가 생성된다. 
				// Student 클래스는 하나지만 new 연산자를 사용한 만큼 객체가 메모리에 생성된다.
				// 이러한 객체들은 Student 클래스의 인스턴스 들이다. 
				// 비록 같은 클래스로부터 생성되었지만 각각의 Student 객체는 자신만의 고유 데이터를
				// 가지면서 메몰에서 활동하게 된다. s1과 s2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체
				
		
	}
	
	
}

class Student {
	
}
