클래스의 개념 
객체 지향 프로그래밍(OOP, Object-Oriented Programming)
객체 지향 프로그래밍에서는 모든 데이터를 객체로 취급하며, 이러한 객체가 바로 프로그래밍의 중심이 된다.

객체(Object)란 간단히 이야기하자면 실생활에서 우리가 인식할 수 있는 사물로 설명할 수 있다.
이러한 객체의 상태와 행동을 구체화 하는 형태의 프로그래밍이 바로 객체 지향 프로그래밍이다.
이때 객체를 만들어 내기 위한 설계도와 같은 개념을 클래스라고 한다.

클래스Class
자바에서 클래스란 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용된다.
자바에서는 이러한 설계도인 클래스를 가지고,여러 객체를 생성하여 사용함

클래스는 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성됨
즉 필드란 클래스에 포함된 변수를 의미함
또한 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

인스턴스 instance
자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체를 선언해야 한다.
이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화라고 한다.
또한, 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스라고 한다.
즉 인스턴스란 메모리에 할당된 객체를 의미함

자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있다.
이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.
하지만 해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.

메소드 method
자바에서 클래스는 멤버로 속성하는 필드와 기능을 표현하는 메소드를 가짐
그중에서 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

자바에서 메소드를 정의하는 방법은 다음과 같다.

문법
접근제어자 반환타입 메소드이름(매개변수 이름){//선언부
            // 구현부
}

1. 접근제어자 : 해당 메소드에 접근할 수 있는 범위를 명시함
2.반환 타입(return type): 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시함
3.메소드 이름 : 메소드를 호출하기 위한 이름을 명시함
4.매개변수 목록(parameters) : 메소드 호출시에 전달되는 인수의 값을 저장할 변수들을 명시 
5.구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합

자바에서는 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 x
but 메소드 오버로딩을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다.
메소드 오버로딩이란 매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다.

이러한 메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있다.
또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 됨

클래스의 구성요소 
자바에서 클래스는 멤버로 속성을 표현하는 -필드와 기능을 표현하는 - 메소드를 가짐 
또한, 클래스는 생성된 객체의 필드를 초기화해주는 특별한 메소드인 생성자(constructor)를 가짐


ex)
class Car {            //클래스 이름 첫글자 대문자로 작성할것
  private String modelName; // 필드
  private int modelYear; // 필드

  Car(String modelName,int modelYear){  // 생성자
    this.modelName = modelName;
    this.modelYear  = modelYear;
  }
  
  public String getModel() {
      return this.modelYear + "년식" + this.modelName + "" + this.color; 
  
  }
}

필드 field
클래스의 필드란 클래스에 포함된 변수(variable)를 의미함
클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분

1.클래스 변수 (static variable)
2.인스턴스 변수 (instance variable)
3.지역 변수 (local variable)

메소드 method
클래스에서 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

즉,메소드를 사용하면 중복되는 코드의 반복적인 프로그래밍을 피할 수 있다. 
또한,모듈화로 인해 전체적인 코드의 가독성이 좋아짐 
그리고 프로그램에 문제가 발생하거나 기능의 변경이 필요할 떄도 손쉽게 유지보수를 할 수 있음

생성자constructor
클래스를 가지고 객체를 생성하면,해당 객체는 메모리에 즉시 생성됨 
하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태 

따라서 자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자라는 메소드를 제공 
자바에서 생성자의 이름은 해당 클래스의 이름과 같아야 함 
즉, Car 클래스의 생성자는 Car()가 됨

클래스의 선언 
클래스란 객체 지향 프로그래밍의 추상화(abstraction)이라는 개념을 직접 구현한 것이라 할 수 있다.
자바에서는 개발자의 편의를 위해 유용하게 사용할 수 있는 많은 수의 클래스를 미리 정의하여 제공하고 있다.
또한, 개발자가 원하는 동작을 하는 새로운 클래스를 손쉽게 작성할 수 도 있다.

자바에서 클래스를 선언하는 방법은 접근 제어자와 함께 class키워드를 사용하면 된다.

자바에서 클래스는 다음과 같이 선언함

정의
접근제어자 class 클래스이름 {
  접근제어자 필드1의타입 필드1의이름;
  접근제어자 필드2의타입 필드2의이름;
  
  접근제어자 메소드1의 원형
  접근제어자 메소드2의 원형
}

인스턴스의 생성 
위와 같이 선언된 클래스의 정의를 가지고 다음과 같은 순서대로 Car객체의 인스턴스를  생성할 수 있다.


참조 변수의 선언과 인스턴스의 생성을 동시에 할수 있다.
ex)

Car myCar = new Car();

메소드 method
자바에서 클래스는 멤버로 속성하는 필드와 기능을 표현하는 메소드를 가짐
그중에서 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

메소드의 사용목적
클래스에서 메소드를 작성하여 사용하는 이유는 중복되는 코드의 반복적인 프로그래밍을 피할 수 있기 떄문
또한,모듈화로 인해 코드의 가독성도 좋아짐

메소드를 작성할 떄는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋음

메소드 정의 
ex)
접근제어자 반환타입 메소드이름(매개변수목록) {//선언부
    //구현부 
}
1.접근 제어자: 해당 메소드에 접근할 수 있는 범위를 명시함
2.반환 타입(return type): 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시함
3.메소드 이름 : 메소드를 호출하기 위한 이름을 명시
4.매개변수 목록(parameters): 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시함
5.구현부: 메소드의 고유 기능을 수행하는 명령문의 집합

메소드 시그니처란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킴
만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 같다면 , 이 두 메소드의 시그니처가 같다고 할 수 있다.

다음은 Car 클래스의 accelerate() 메소드를 정의하는 예제
ex)
class Car {
  private int currentSpeed;
  private int aceelerationTime;
  
  public void accelerate(int speed,int second){ // 선언부
      System.out.println(second + "초간 속도를 시속"+spped + "가속 한다 ");  //구현부
  }
}

위 예제의 1번 라인에서는 accelerate()메소드를 정의하고 있다.
이 메소드는 public 접근 제어자를 사용하여 선언되어 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다.
반환 타입에는 어떠한 값도 반환하지 않는다는 의미를 가진 void를 명시함
그 다음으로 메소드의 이름을 명시하고, 매개변수로 int형 변수인 speed와 second를 전달받음
이렇게 전달받은 매개변수를 가지고 메소드 구현부에서 고유한 작업을 수행할 수 있는 것이다.

메소드 호출
자바에서 위와 같은 방법으로 정의한 메소드는 멤버 참조 연산자(.)를 사용하여 호출할 수 있다.

자바에서 메소드를 호출하는 방법은 다음과 같다.

1.객체참조변수이름.메소드이름(); //매개변수가 없는 메소드의 호출
2.객체참조변수이름.메소드이름(인수1,인수2)// 매개 변수가 없는 메소드의 호출

다음 예제는 앞서 정의한 accelerate()메소드를 호출하는 예제
ex)
Car myCar  = new Car(); //객체를 생성함
myCar.accelerate(60,3); // myCar 인스턴스의 accelerate()메소드를 호출함


생성자
인스턴스 변수의 초기화 
클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성됨
하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태 
하지만 사용자가 원하는 값으로 인스턴스 변수를 초기화하려면,일반적인 초기화 방식으로는 초기화 할 수 없다.
인스턴스 변수 중에는 private변수도 있으며, 이러한 private변수에는 사용자나 프로그램이 직접 접근할 수 없기 떄문
따라서 private인스턴스 변수에도 접근할 수 있는 초기화만을 위한 public 메소드가 필요해짐
이러한 초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되어야 한다.

생성자
자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화 할 수 있는 생성자라는 메소드를 제공함 
자바에서 생성자의 이름은 해당 클래스의 이름과 같아야 한다.

이러한 생성자는 다음과 같은 특징을 가짐 

1.생성자는 반환값이 없지만,반환 타입을 void형으로 선언하지 않는다.
2.생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.
3.객체를 초기화하는 방법이 여러개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다.
 즉,생성자도 하나의 메소드이므로,메소드 오버로딩이 가능하다는 의미이다
 
 생성자의 선언
 자바에서 클래스 생성자를 선언하는 문법은 다음과 같다.
 1.클래스 이름() {...} // 매개변수가 없는 생성자 선언
 2.클래스 이름(인수1,인수2) // 매개변수가 있는 생성자 선언
 
 생성자 예제
 Car() {  //이처럼 클래스 생성자는 어떠한 반환값도 명시 안함 생성자는 
 
 }
 
 생성자의 호출 
 자바에서는 new키워드를 사용하여 객체를 생성할 떄 자동으로 생성자가 호출됨
 
 기본 생성자 default constructor
 자바의 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다.
 하지만 특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있다.
 이것은 자바 컴파일러가 기본 생성자라는 것을 기본적으로 제공해 주기 떄문 
 기본 생성자는 매개변수를 하나도 가지지x , 아무런 명령어도 포함하지 x
 
 
 this와 this()
 this 참조변수
 this 참조 변수는 인스턴스가 바로 자기 자신을 참조하는데 사용하는 변수이다.
 이러한 this 참조 변수는 해당 인스턴스의 주소를 가리킴 
 
 다음 예제는 Car 클래스의 생성자를 나타낸 예제
 ex)
 class Car {
  private String modelName;
  private int modelYear;
  private String color;
  private int maxSpeed;
  private int currentSpeed;
  
  Car(String modelName, int modelYear, String color, int maxSpeed) {
    this.modelName = modelName;
    this.modelYear = modelYear;
    this.color = color;
    this.maxSpeed = maxSpeed;
    this.currentSpeed = 0;
  }
 }
위의 예제처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 인스턴스 변수 앞에 this키워드를 붙여 구분해야 한다.
이렇게 자바에서는 this참조 변수를 사용하여 인스턴스 변수에 접근할 수 있다.
이러한 this참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드(static)에서는 사용할수 x
모든 인스턴스 메소드에는 this참조 변수가 숨겨진 지역변수로 존재하고 있다.

 this()메소드 
 this()메소드는 생성자 내부에서만 사용할 수 있으며,같은 클래스의 다른 생성자를 호출할 떄 사용함
 this()메소드에 인수를 전달하면, 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해 줌
 
 다음 예제는 this참조 변수와 this()메소드를 사용한 예제
 ex)
 class Car{
  
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;
    
    Car(String modelName,int modelYear, String color,int maxSpeed){
      this.modelName = modelName;
      this.modelYear = modelYear;
      this.color = color;
      this.maxSpeed = maxSpeed;
    }
    
    Car(){
      this("소나타",2012,"검정색",160); // 다른 생성자를 호출함
    }
    
    public String getModel() {
    
      return this.modelYear + "년식" + this.modelName + " " + this.color;
    }
 }
 
 public class Method05 {
 
  public static void main(String[] args){
  
    Car tcpCar = new Car();
    System.out.println(tcpCar.getModel());
  }
 }
 
 메소드 시그니처
 메소드 오버로딩의 핵심은 바로 메소드 시그니처에 있다.
 메소드 시그니처란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킴
 
 만약 두 메소드가 매개변수의 개수와 타입,그 순서까지 같다면, 이 두메소드는 시그니처는 같다고 할 수 있다.
 
 메소드 오버로딩
 메소드 오버로딩이란 같은 이름의 메소드를 중복하여 정의하는 것을 의미 
 but 매개 변수의 개수나 타입을 다르게 하면, 하나의 이름으로 메소드 작성 o
 이렇게 하면 메소드를 호출할 떄 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경쓰지 않고 호출할 수 있게 된다.
 메소드 오버로딩은 객체 지향 프로그래밍의 특징 중 하나인 다형성을 구현하는 방법중 하나이다.
 메소드 오버로딩 예로는
 println()
 
 그리고 메소드 오버로딩은 반환타입과는 관계x   
 메소드 오버로딩 조건은 
 1.메소드 이름 같아야 하고 
 2.메소드의 시그니처, 즉 매개변수의 개수 or 타입이 달라야 한다.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

































